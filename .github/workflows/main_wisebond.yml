name: Deploy to Azure App Service (Native Node.js)

on:
  push:
    branches:
     - main
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AZURE_WEBAPP_NAME: WiseBond
  NODE_VERSION: '22.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Clean and install dependencies to fix Rollup native error
      run: |
        echo "Cleaning up previous installs..."
        rm -rf node_modules package-lock.json dist/ .cache/
        echo "Clearing npm cache to ensure fresh dependencies..."
        npm cache clean --force
        echo "Installing dependencies with fallback support for optional native modules..."
        npm install
        echo "Verifying postgres module installation..."
        ls -la node_modules/postgres/ || echo "Postgres module not found in expected location"
    
    # - name: Run type checking
    #   run: npm run check
    
    - name: Build application with proper path mapping
      run: |
        echo "Starting build process with proper path mapping..."
        
        # Build the entire application
        npm run build
        
        # Verify the build output
        echo "Verifying build output..."
        ls -la dist/
        
        # More robust verification
        if [ -f "dist/index.js" ]; then
          echo "‚úÖ dist/index.js found"
          ls -la dist/index.js
        else
          echo "‚ùå Server build failed - dist/index.js not found"
          echo "Contents of dist directory:"
          ls -la dist/
          exit 1
        fi
        
        echo "‚úÖ Build completed successfully"
    
    - name: Create ultra-optimized deployment package
      run: |
        echo "Creating minimal deployment package..."
        
        # Create deployment directory
        mkdir -p minimal-deploy
        
        # Copy only essential runtime files
        cp package.json minimal-deploy/
        
        # Copy built application
        cp -r dist/ minimal-deploy/
        
        # Copy shared directory (required for database schema)
        cp -r shared/ minimal-deploy/
        
        # Copy config files
        cp web.config minimal-deploy/
        
        # Create minimal package.json for production (include all runtime dependencies)
        cat > minimal-deploy/package.json << 'EOF'
        {
          "name": "wisebond-production",
          "version": "1.0.0",
          "type": "module",
          "scripts": {
            "start": "node dist/index.js"
          },
          "engines": {
            "node": "22.x"
          },
          "dependencies": {
            "express": "^4.21.2",
            "express-session": "^1.18.2",
            "passport": "^0.7.0",
            "passport-local": "^1.0.0",
            "bcrypt": "^5.1.1",
            "dotenv": "^16.4.7",
            "drizzle-orm": "^0.36.4",
            "postgres": "^3.4.7",
            "connect-pg-simple": "^10.0.0",
            "helmet": "^7.1.0",
            "cors": "^2.8.5",
            "compression": "^1.7.4",
            "mailgun.js": "^12.0.1",
            "axios": "^1.11.0",
            "zod": "^3.23.8",
            "pdf-lib": "^1.17.1",
            "puppeteer": "^24.10.1",
            "ws": "^8.18.2",
            "@azure/identity": "^4.10.0",
            "@azure/keyvault-secrets": "^4.9.0",
            "handlebars": "^4.7.8",
            "date-fns": "^3.6.0",
            "form-data": "^4.0.4",
            "http-errors": "^2.0.0",
            "path-to-regexp": "^0.1.12",
            "drizzle-zod": "^0.5.1",
            "nanoid": "^5.1.5",
            "zod-validation-error": "^3.4.0"
          }
        }
        EOF
        
        # Install ONLY essential production dependencies
        cd minimal-deploy
        npm install --production --no-optional --no-dev --silent
        
        # Ultra-aggressive cleanup for maximum size reduction
        echo "Ultra-aggressive cleanup for maximum size reduction..."
        
        # Remove all documentation and test files
        find node_modules -name "*.md" -delete 2>/dev/null || true
        find node_modules -name "*.txt" -delete 2>/dev/null || true
        find node_modules -name "*.map" -delete 2>/dev/null || true
        find node_modules -name "*test*" -type f -delete 2>/dev/null || true
        find node_modules -name "*spec*" -type f -delete 2>/dev/null || true
        find node_modules -name "example*" -delete 2>/dev/null || true
        find node_modules -name "LICENSE*" -delete 2>/dev/null || true
        find node_modules -name "CHANGELOG*" -delete 2>/dev/null || true
        find node_modules -name "README*" -delete 2>/dev/null || true
        find node_modules -name ".git*" -delete 2>/dev/null || true
        find node_modules -name "*.ts" -not -path "*/types/*" -delete 2>/dev/null || true
        find node_modules -name "*.d.ts" -not -path "*/types/*" -not -path "*/@types/*" -delete 2>/dev/null || true
        find node_modules -name "*.flow" -delete 2>/dev/null || true
        find node_modules -name "*.coffee" -delete 2>/dev/null || true
        find node_modules -name "*.scss" -delete 2>/dev/null || true
        find node_modules -name "*.less" -delete 2>/dev/null || true
        find node_modules -name "*.styl" -delete 2>/dev/null || true
        find node_modules -name "*.tsbuildinfo" -delete 2>/dev/null || true
        find node_modules -name ".eslintrc*" -delete 2>/dev/null || true
        find node_modules -name ".prettierrc*" -delete 2>/dev/null || true
        find node_modules -name "jest.config.*" -delete 2>/dev/null || true
        find node_modules -name "rollup.config.*" -delete 2>/dev/null || true
        find node_modules -name "webpack.config.*" -delete 2>/dev/null || true
        
        # Remove entire directory structures that aren't needed
        rm -rf node_modules/*/test/ 2>/dev/null || true
        rm -rf node_modules/*/tests/ 2>/dev/null || true
        rm -rf node_modules/*/__tests__/ 2>/dev/null || true
        rm -rf node_modules/*/coverage/ 2>/dev/null || true
        rm -rf node_modules/*/.nyc_output/ 2>/dev/null || true
        rm -rf node_modules/*/benchmark/ 2>/dev/null || true
        rm -rf node_modules/*/docs/ 2>/dev/null || true
        rm -rf node_modules/*/example*/ 2>/dev/null || true
        rm -rf node_modules/*/demo*/ 2>/dev/null || true
        rm -rf node_modules/*/.cache/ 2>/dev/null || true
        rm -rf node_modules/*/man/ 2>/dev/null || true
        rm -rf node_modules/*/src/ 2>/dev/null || true
        
        # Remove binary files from packages that have both binary and JS versions
        find node_modules -name "*.exe" -delete 2>/dev/null || true
        find node_modules -name "*.dll" -delete 2>/dev/null || true
        find node_modules -name "*.dylib" -delete 2>/dev/null || true
        find node_modules -name "*.so" -delete 2>/dev/null || true
        
        cd ..
        
        # Create deployment zip with maximum compression
        cd minimal-deploy
        zip -9 -r ../deployment.zip . -q
        cd ..
        
        # Show size comparison and validation
        echo "üì¶ Ultra-optimized deployment package results:"
        echo "Compressed package: $(du -sh deployment.zip | cut -f1)"
        echo "Uncompressed package: $(du -sh minimal-deploy | cut -f1)"
        
        # Check final size and warn if still large
        FINAL_SIZE=$(stat --format=%s deployment.zip)
        FINAL_SIZE_MB=$(echo "scale=1; $FINAL_SIZE / 1024 / 1024" | bc)
        echo "Final deployment package size: ${FINAL_SIZE_MB}MB"
        
        if [ $FINAL_SIZE -gt 104857600 ]; then
          echo "‚ö†Ô∏è  Warning: Package is still large (>100MB). This may cause deployment conflicts."
          echo "Consider further optimization or switching to container deployment."
        else
          echo "‚úÖ Package size is optimized for reliable deployment."
        fi

    - name: 'Login to Azure'
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Pre-deployment cleanup (prevent conflicts)
      run: |
        echo "üßπ Preparing Azure App Service for deployment..."
        
        # Stop the app to ensure clean deployment
        echo "Stopping app service to clear any file locks..."
        az webapp stop --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} || true
        sleep 10
        
        # Check deployment history (using correct command)
        echo "Checking deployment history..."
        az webapp deployment list-publishing-profiles --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} --output table || true
        
        # Clear application cache and temporary files
        echo "Clearing application cache and temp files..."
        az webapp config appsettings set --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} --settings WEBSITE_CLEAR_CACHE=1 || true
        
        # Set Node.js optimization settings for better ES module compatibility
        echo "Setting Node.js optimization settings..."
        az webapp config appsettings set --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} --settings NODE_OPTIONS="--max-old-space-size=1024 --experimental-specifier-resolution=node" || true
        
        # Ensure Oryx build is disabled since we're using pre-built packages
        echo "Configuring build settings for pre-built deployment..."
        az webapp config appsettings set --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} --settings SCM_DO_BUILD_DURING_DEPLOYMENT=false || true
        az webapp config appsettings set --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} --settings ENABLE_ORYX_BUILD=false || true
        
        # Force restart to clear all cached modules
        echo "Forcing app restart to clear cached modules..."
        az webapp restart --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} || true
        sleep 15
        
        echo "‚úÖ Pre-deployment cleanup completed"
        
    - name: Deploy to Azure Web App (Primary attempt)
      id: primary_deploy
      uses: azure/webapps-deploy@v3
      continue-on-error: true
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        slot-name: 'production'
        package: deployment.zip
        clean: true              # Clean existing files before deployment
        restart: true            # Restart app after deployment
        startup-command: 'npm start'  # Explicit startup command
        
    - name: Handle deployment conflict (409 error recovery)
      if: steps.primary_deploy.outcome == 'failure'
      run: |
        echo "‚ö†Ô∏è  Primary deployment failed. Implementing 409 conflict recovery..."
        echo "Waiting 45 seconds for any file locks to release..."
        sleep 45
        
        echo "Restarting app service to clear conflicts..."
        az webapp restart --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }}
        sleep 15
        
        echo "‚úÖ Conflict recovery completed, ready for retry"
        
    - name: Deploy to Azure Web App (Retry attempt)
      if: steps.primary_deploy.outcome == 'failure'
      id: retry_deploy
      uses: azure/webapps-deploy@v3
      continue-on-error: true
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        slot-name: 'production'
        package: deployment.zip
        clean: true              # Clean existing files before deployment
        restart: true            # Restart app after deployment
        
    - name: Deploy using Azure CLI (Final fallback)
      if: steps.primary_deploy.outcome == 'failure' && steps.retry_deploy.outcome == 'failure'
      run: |
        echo "üîÑ Both webapps-deploy attempts failed. Using Azure CLI as fallback..."
        
        # Stop the app to prevent conflicts
        echo "Stopping app service..."
        az webapp stop --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }}
        sleep 10
        
        # Deploy using zip deployment
        echo "Deploying via Azure CLI zip deployment..."
        az webapp deployment source config-zip \
          --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --src deployment.zip
        
        # Start the app
        echo "Starting app service..."
        az webapp start --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }}
        
        echo "‚úÖ Fallback deployment completed via Azure CLI"
        
    - name: Verify deployment success
      run: |
        echo "üîç Verifying deployment..."
        
        # Wait for app to be ready
        sleep 30
        
        # Check app status
        APP_STATE=$(az webapp show --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ secrets.AZURE_RESOURCE_GROUP || 'your-resource-group' }} --query "state" --output tsv)
        echo "App Service State: $APP_STATE"
        
        if [ "$APP_STATE" = "Running" ]; then
          echo "‚úÖ App Service is running successfully"
        else
          echo "‚ö†Ô∏è  App Service state: $APP_STATE"
        fi
        
        # Test the endpoint (optional)
        echo "Testing application endpoint..."
        HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/ || echo "000")
        echo "HTTP Response Code: $HTTP_STATUS"
        
        if [ "$HTTP_STATUS" = "200" ]; then
          echo "‚úÖ Application is responding successfully"
        else
          echo "‚ö†Ô∏è  Application returned HTTP $HTTP_STATUS"
        fi

    - name: üéâ Deployment Summary
      run: |
        echo "‚úÖ Deployment pipeline completed!"
        echo "üåê Application URL: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        echo "üìä Package size: $(du -sh deployment.zip | cut -f1)"
        echo "üõ°Ô∏è  Deployment method: Multi-stage with conflict resolution"
        echo "‚è±Ô∏è  Total deployment time: ~3-4 minutes (with conflict handling)"
        
        # Deployment status summary
        if [ "${{ steps.primary_deploy.outcome }}" = "success" ]; then
          echo "‚úÖ Primary deployment: SUCCESS"
        elif [ "${{ steps.retry_deploy.outcome }}" = "success" ]; then
          echo "‚úÖ Retry deployment: SUCCESS (after conflict resolution)"
        else
          echo "‚úÖ Fallback deployment: SUCCESS (via Azure CLI)"
        fi